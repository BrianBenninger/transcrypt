#!/usr/bin/env bash

#
# transcrypt - https://github.com/elasticdog/transcrypt
#
# A script to configure transparent encryption of sensitive files stored in
# a Git repository. It utilizes OpenSSL's symmetric cipher routines and follows
# the gitattributes man page regarding the use of filters.
#
# Copyright (c) 2014 Aaron Bull Schaefer <aaron@elasticdog.com>
# This source code is provided under the terms of the MIT License
# that can be be found in the LICENSE file.
#

##### Constants

readonly VERSION='0.2.0'               # the release version of this script
readonly BASENAME="${0##*/}"           # the name of this script for error output
readonly DEFAULT_CIPHER='aes-256-cbc'  # the default cipher to utilize

# the current git repository's top-level directory
readonly REPO=$(git rev-parse --show-toplevel 2> /dev/null)

# whether or not transcrypt is already configured
readonly CONFIGURED=$(git config --get --local transcrypt.version 2> /dev/null)

# regular expressions used to test user input
readonly YES_REGEX='^[Yy]$'
readonly HEX_REGEX='^[0-9A-Fa-f]+$'

##### Functions

# print a message to stderr
warn() {
	local fmt="$1"
	shift
	printf "$BASENAME: $fmt\n" "$@" >&2
}

# print a message to stderr and exit with either
# the given status or that of the most recent command
die() {
	local st="$?"
	if [[ "$1" != *[^0-9]* ]]; then
		st="$1"
		shift
	fi
	warn "$@"
	exit "$st"
}

# verify that all requirements have been met
run_safety_checks() {
	# validate that we're in a git repository
	[[ $REPO ]] || die 'you are not currently in a git repository; did you forget to run "git init"?'

	# see if transcrypt is already configured
	[[ $CONFIGURED ]] && die 1 'the current repository is already configured; see --display'

	# check for dependencies
	command -v openssl > /dev/null || die 'required command "openssl" was not found'
}

# unset the cipher variable if it is not supported by openssl
validate_cipher() {
	local supported=$(openssl list-cipher-commands | grep --line-regexp "$cipher")
	if [[ ! $supported ]]; then
		printf '"%s" is not a valid cipher; choose one of the following:\n\n' $cipher
		openssl list-cipher-commands | column -c 80
		printf '\n'
		unset cipher
	fi
}

# ensure we have a cipher to encrypt with
get_cipher() {
	while [[ ! $cipher ]]
	do
		local answer
		printf 'Encrypt using which cipher? [%s] ' $DEFAULT_CIPHER
		read -r answer

		# use the default cipher if the user gave no answer;
		# otherwise verify the given cipher is supported by openssl
		if [[ ! $answer ]]; then
			cipher=$DEFAULT_CIPHER
		else
			cipher=$answer
			validate_cipher
		fi
	done
}

# ensure we have a password to encrypt with
get_password() {
	while [[ ! $password ]]
	do
		local answer
		printf 'Generate a random password? [Y/n] '
		read -r -n 1 -s answer
		printf '\n'

		# generate a random password if the user answered yes;
		# otherwise prompt the user for a password
		if [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then
			local password_length=32
			local random_alnum=$(LC_ALL=C tr -cd '[:alnum:]' < /dev/urandom | head -c $password_length)
			password=$random_alnum
		else
			printf 'Password: '
			read -r password
			[[ ! $password ]] && printf 'no password was specified\n'
		fi
		printf '\n'
	done
}

# confirm the transcrypt configuration
confirm_configuration() {
	local answer

	printf 'The following configuration will be saved:\n\n'
	printf '  REPO:     %s\n' $REPO
	printf '  CIPHER:   %s\n' $cipher
	printf '  PASSWORD: %s\n\n' $password
	printf 'Does this look correct? [Y/n] '
	read -r -n 1 -s answer

	# exit if the user did not confirm
	if [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then
		printf '\n\n'
	else
		printf '\n'
		die 1 'configuration has been aborted'
	fi
}

# write the configuration to the repository's .git/config
save_configuration() {
	# write the encryption info
	git config --add transcrypt.version "$VERSION"
	git config --add transcrypt.cipher "$cipher"
	git config --add transcrypt.password "$password"

	# the `decryption -> encryption` process on an unchanged file must be
	# deterministic for everything to work transparently. to do that, the same
	# salt must be used each time we encrypt the file. rather than use
	# a static salt common to all files, we'll take a hash of each file
	# individually (when it's decrypted) and use the last 16 bytes of that
	# hash for its unique salt.
	local cipher_cmd='$(git config --get --local transcrypt.cipher)'
	local password_cmd='$(git config --get --local transcrypt.password)'
	local salt_cmd='$(openssl dgst -sha256 %f | tail -c 16)'

	# write the filter settings
	git config filter.crypt.clean "openssl enc -$cipher_cmd -pass pass:$password_cmd -e -a -S $salt_cmd"
	git config filter.crypt.smudge "openssl enc -$cipher_cmd -pass pass:$password_cmd -d -a"
	git config filter.crypt.required 'true'
	git config diff.crypt.textconv "openssl enc -$cipher_cmd -pass pass:$password_cmd -d -a -in \$1 2> /dev/null || cat"
	git config merge.renormalize 'true'

	# add a git alias for listing encrypted files
	git config alias.ls-crypt "!git ls-files | git check-attr --stdin filter | awk 'BEGIN { FS = \":\" }; /crypt$/{ print \$1 }'"
}

# display the current configuration settings
display_configuration() {
	if [[ ! $CONFIGURED ]]; then
		printf 'transcrypt is not configured for this repository\n'
	else
		local current_version=$(git config --get --local transcrypt.version)
		local current_cipher=$(git config --get --local transcrypt.cipher)
		local current_password=$(git config --get --local transcrypt.password)

		printf 'The current repository was configured using transcrypt v%s\n' $current_version
		printf 'and has the following configuration:\n\n'
		printf '  CIPHER:   %s\n' $current_cipher
		printf '  PASSWORD: %s\n\n' $current_password
		printf 'Copy and paste the following command to initialize a cloned repository:\n\n'
		printf '  transcrypt -c %s -p %s\n' $current_cipher $current_password
	fi
}

# print this script's usage message to stderr
usage() {
	cat <<-EOF >&2
	usage: transcrypt [-c CIPHER] [-p PASSWORD] [-d] [-v] [-h]
	EOF
}

# print this script's help message to sdtout
help() {
	cat <<-EOF

	NAME
	     transcrypt -- transparently encrypt files within a git repository

	SYNOPSIS
	     transcrypt [-c CIPHER] [-p PASSWORD] [-d] [-v] [-h]

	DESCRIPTION
	     transcrypt will configure a Git repository to support the transparent
	     encryption/decryption of files utilizing OpenSSL's symmetric cipher
	     routines. It will also add a Git alias "ls-crypt" to list all
	     transparently encrypted files within the repository.

	     transcrypt will prompt the user interactively for all required
	     information if the corresponding option flags were not given.

	OPTIONS
	     -p, --password=PASSWORD
	          the password to derive the key from

	     -c, --cipher=CIPHER
	          the symmetric cipher to utilize for encryption;
	          defaults to aes-256-cbc

	     -d, --display
	          display the current repository's cipher and password

	     -v, --version
	          print the version information

	     -h, --help
	          view this help message

	USAGE
	      Once a repository has been configured with transcrypt, you can
	      transparently encrypt files by applying the "crypt" filter and diff
	      to a pattern in the top-level .gitattributes config. If that pattern
	      matches a file in your repository, the file will be transparently
	      encrypted once you stage and commit it:

	        $ echo 'sensitive_file  filter=crypt diff=crypt' >> .gitattributes
	        $ git add .gitattributes sensitive_file
	        $ git commit -m 'Add encrypted version of a sensitive file'

	      See the gitattributes(5) man page for more information.

	      If you have just cloned a repository containing files that are
	      encrypted, you'll want to configure transcrypt with the same
	      cipher and password as the origin repository, then force a checkout
	      of all encrypted files to decrypt them:

	        $ transcrypt
	        $ git checkout --force -- \$(git ls-crypt)

	      WARNING! Since we're dealing with `git checkout --force`, you should
	      make sure to commit or stash all changes in your working directory
	      before performing the above action, just to be safe.
	EOF
}


##### Main

# reset all variables that might be set
cipher=''
password=''

# parse command line options
while [[ "$1" != '' ]]
do
	case $1 in
		-h | --help | -\?)
			help
			exit 0
			;;
		-v | --version)
			printf "$BASENAME $VERSION\n"
			exit 0
			;;
		-d | --display)
			display_configuration
			exit 0
			;;
		-c | --cipher)
			cipher=$2
			shift
			validate_cipher
			;;
		--cipher=*)
			cipher=${1#*=}
			validate_cipher
			;;
		-p | --password)
			password=$2
			shift
			;;
		--password=*)
			password=${1#*=}
			;;
		--*)
			warn "unknown option -- ${1#--}"
			usage
			exit 1
			;;
		*)
			warn "unknown option -- ${1#-}"
			usage
			exit 1
			;;
	esac
	shift
done

# perform function calls
run_safety_checks
get_cipher
get_password
confirm_configuration
save_configuration

# ensure the gitattributes file exists
if [[ ! -f "$REPO/.gitattributes" ]]; then
	printf '#pattern  filter=crypt diff=crypt\n' > "$REPO/.gitattributes"
fi

printf 'transcrypt has been successfully configured!\n'

exit 0
