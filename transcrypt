#!/usr/bin/env bash

#
# transcrypt - https://github.com/elasticdog/transcrypt
#
# A script to configure transparent encryption of sensitive files stored in
# a Git repository. It utilizes OpenSSL's symmetric cipher routines and follows
# the gitattributes(5) man page regarding the use of filters.
#
# Copyright (c) 2014 Aaron Bull Schaefer <aaron@elasticdog.com>
# This source code is provided under the terms of the MIT License
# that can be be found in the LICENSE file.
#

##### Constants

# the release version of this script
readonly VERSION='0.2.0'

# the default cipher to utilize
readonly DEFAULT_CIPHER='aes-256-cbc'

# the current git repository's top-level directory
readonly REPO=$(git rev-parse --show-toplevel 2> /dev/null)

# whether or not transcrypt is already configured
readonly CONFIGURED=$(git config --get --local transcrypt.version 2> /dev/null)

# whether or not a HEAD revision exists
readonly HEAD_EXISTS=$(git rev-parse --verify --quiet HEAD 2> /dev/null)

# regular expression used to test user input
readonly YES_REGEX='^[Yy]$'


##### Functions

# print a message to stderr
warn() {
	local fmt="$1"
	shift
	printf "transcrypt: $fmt\n" "$@" >&2
}

# print a message to stderr and exit with either
# the given status or that of the most recent command
die() {
	local st="$?"
	if [[ "$1" != *[^0-9]* ]]; then
		st="$1"
		shift
	fi
	warn "$@"
	exit "$st"
}

# verify that all requirements have been met
run_safety_checks() {
	# validate that we're in a git repository
	[[ $REPO ]] || die 'you are not currently in a git repository; did you forget to run "git init"?'

	# see if transcrypt is already configured
	[[ $CONFIGURED ]] && die 1 'the current repository is already configured; see --display'

	# check for dependencies
	command -v openssl > /dev/null || die 'required command "openssl" was not found'

	# ensure the repository is clean so we can decrypt any existing
	# files later on by forcing a checkout of the HEAD revision
	if [[ $HEAD_EXISTS ]]; then
		# check if the repo is dirty
		if ! git diff-index --quiet HEAD; then
			die 1 'the repo is dirty; commit or stash your changes before running transcrypt'
		fi
	fi
}

# unset the cipher variable if it is not supported by openssl
validate_cipher() {
	local supported=$(openssl list-cipher-commands | grep --line-regexp "$cipher")
	if [[ ! $supported ]]; then
		if [[ $interactive ]]; then
			printf '"%s" is not a valid cipher; choose one of the following:\n\n' "$cipher"
			openssl list-cipher-commands | column -c 80
			printf '\n'
		else
			die 1 '"%s" is not a valid cipher; see `openssl list-cipher-commands`' "$cipher"
		fi
		unset cipher
	fi
}

# ensure we have a cipher to encrypt with
get_cipher() {
	while [[ ! $cipher ]]
	do
		local answer
		if [[ $interactive ]]; then
			printf 'Encrypt using which cipher? [%s] ' "$DEFAULT_CIPHER"
			read -r answer
		fi

		# use the default cipher if the user gave no answer;
		# otherwise verify the given cipher is supported by openssl
		if [[ ! $answer ]]; then
			cipher=$DEFAULT_CIPHER
		else
			cipher=$answer
			validate_cipher
		fi
	done
}

# ensure we have a password to encrypt with
get_password() {
	while [[ ! $password ]]
	do
		local answer
		if [[ $interactive ]]; then
			printf 'Generate a random password? [Y/n] '
			read -r -n 1 -s answer
			printf '\n'
		fi

		# generate a random password if the user answered yes;
		# otherwise prompt the user for a password
		if [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then
			local password_length=30
			local random_base64=$(openssl rand -base64 $password_length)
			password=$random_base64
		else
			printf 'Password: '
			read -r password
			[[ ! $password ]] && printf 'no password was specified\n'
		fi
	done
}

# confirm the transcrypt configuration
confirm_configuration() {
	local answer

	printf '\nThe following configuration will be saved:\n\n'
	printf '  REPO:     %s\n' "$REPO"
	printf '  CIPHER:   %s\n' "$cipher"
	printf '  PASSWORD: %s\n\n' "$password"
	printf 'Does this look correct? [Y/n] '
	read -r -n 1 -s answer

	# exit if the user did not confirm
	if [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then
		printf '\n\n'
	else
		printf '\n'
		die 1 'configuration has been aborted'
	fi
}

# write the configuration to the repository's .git/config
save_configuration() {
	# write the encryption info
	git config --add transcrypt.version "$VERSION"
	git config --add transcrypt.cipher "$cipher"
	git config --add transcrypt.password "$password"

	# the `decryption -> encryption` process on an unchanged file must be
	# deterministic for everything to work transparently. to do that, the same
	# salt must be used each time we encrypt the file. rather than use
	# a static salt common to all files, we'll take a hash of each file
	# individually (when it's decrypted) and use the last 16 bytes of that
	# hash for its unique salt.
	local cipher_cmd='$(git config --get --local transcrypt.cipher)'
	local password_cmd='$(git config --get --local transcrypt.password)'
	local salt_cmd='$(openssl dgst -sha256 %f | tail -c 16)'

	# write the filter settings
	git config filter.crypt.clean "openssl enc -$cipher_cmd -pass \"pass:$password_cmd\" -e -a -S $salt_cmd"
	git config filter.crypt.smudge "openssl enc -$cipher_cmd -pass \"pass:$password_cmd\" -d -a"
	git config filter.crypt.required 'true'
	git config diff.crypt.textconv "openssl enc -$cipher_cmd -pass \"pass:$password_cmd\" -d -a -in \$1 2> /dev/null || cat"
	git config merge.renormalize 'true'

	# add a git alias for listing encrypted files
	git config alias.ls-crypt "!git ls-files | git check-attr --stdin filter | awk 'BEGIN { FS = \":\" }; /crypt$/{ print \$1 }'"
}

# decrypt any existing encrypted files that may exist
decrypt_existing() {
	# make sure a HEAD revision exists
	if [[ $HEAD_EXISTS ]]; then
		# this would normally delete uncommitted changes in the working directory,
		# but we already made sure the repo was clean during the safety checks
		git checkout --force HEAD -- $(git ls-crypt) > /dev/null
	fi
}

# display the current configuration settings
display_configuration() {
	if [[ $CONFIGURED ]]; then
		local current_cipher=$(git config --get --local transcrypt.cipher)
		local current_password=$(git config --get --local transcrypt.password)
		local escaped_password=${current_password//\'/\'\\\'\'}

		printf 'The current repository was configured using transcrypt v%s\n' "$CONFIGURED"
		printf 'and has the following configuration:\n\n'
		printf '  CIPHER:   %s\n' "$current_cipher"
		printf '  PASSWORD: %s\n\n' "$current_password"
		printf 'Copy and paste the following command to initialize a cloned repository:\n\n'
		printf "  transcrypt -c %s -p '%s' -y \n" "$current_cipher" "$escaped_password"
	else
		printf 'transcrypt is not configured for this repository\n'
	fi
}

# print this script's usage message to stderr
usage() {
	cat <<-EOF >&2
	usage: transcrypt [-c CIPHER] [-p PASSWORD] [-y] [-d] [-v] [-h]
	EOF
}

# print this script's help message to sdtout
help() {
	cat <<-EOF

	NAME
	     transcrypt -- transparently encrypt files within a git repository

	SYNOPSIS
	     transcrypt [-c CIPHER] [-p PASSWORD] [-y] [-d] [-v] [-h]

	DESCRIPTION
	     transcrypt will configure a Git repository to support the transparent
	     encryption/decryption of files utilizing OpenSSL's symmetric cipher
	     routines. It will also add a Git alias "ls-crypt" to list all
	     transparently encrypted files within the repository.

	     transcrypt will prompt the user interactively for all required
	     information if the corresponding option flags were not given.

	OPTIONS
	     -p, --password=PASSWORD
	          the password to derive the key from;
	          defaults to 30 random base64 characters

	     -c, --cipher=CIPHER
	          the symmetric cipher to utilize for encryption;
	          defaults to aes-256-cbc

	     -y, --yes
	          assume yes and accept defaults for non-specified options

	     -d, --display
	          display the current repository's cipher and password

	     -v, --version
	          print the version information

	     -h, --help
	          view this help message

	USAGE
	      Once a repository has been configured with transcrypt, you can
	      transparently encrypt files by applying the "crypt" filter and diff
	      to a pattern in the top-level .gitattributes config. If that pattern
	      matches a file in your repository, the file will be transparently
	      encrypted once you stage and commit it:

	        $ echo 'sensitive_file  filter=crypt diff=crypt' >> .gitattributes
	        $ git add .gitattributes sensitive_file
	        $ git commit -m 'Add encrypted version of a sensitive file'

	      See the gitattributes(5) man page for more information.

	      If you have just cloned a repository containing files that are
	      encrypted, you'll want to configure transcrypt with the same cipher
	      and password as the origin repository. Once transcrypt has stored
	      the matching credentials, it will force a checkout of any exising
	      encrypted files in order to decrypt them.
	EOF
}


##### Main

# reset all variables that might be set
cipher=''
password=''
interactive='true'

# parse command line options
while [[ "$1" != '' ]]
do
	case $1 in
		-h | --help | -\?)
			help
			exit 0
			;;
		-v | --version)
			printf "transcrypt $VERSION\n"
			exit 0
			;;
		-d | --display)
			display_configuration
			exit 0
			;;
		-c | --cipher)
			cipher=$2
			shift
			;;
		--cipher=*)
			cipher=${1#*=}
			;;
		-p | --password)
			password=$2
			shift
			;;
		--password=*)
			password=${1#*=}
			;;
		-y | --yes)
			unset interactive
			;;
		--*)
			warn "unknown option -- ${1#--}"
			usage
			exit 1
			;;
		*)
			warn "unknown option -- ${1#-}"
			usage
			exit 1
			;;
	esac
	shift
done

# in order to keep behavior consistent no matter what order the options were
# specified in, we must run this here rather than in the case statement above
[[ $cipher ]] && validate_cipher

# perform function calls
run_safety_checks
get_cipher
get_password
[[ $interactive ]] && confirm_configuration
save_configuration
decrypt_existing

# ensure the gitattributes file exists
if [[ ! -f "$REPO/.gitattributes" ]]; then
	printf '#pattern  filter=crypt diff=crypt\n' > "$REPO/.gitattributes"
fi

printf 'transcrypt has been successfully configured!\n'

exit 0
